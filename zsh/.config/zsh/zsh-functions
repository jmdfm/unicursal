# Function to source files if they exist
function zsh_add_file() {
    [ -f "$ZDOTDIR/$1" ] && source "$ZDOTDIR/$1"
}

function zsh_add_plugin() {
    PLUGIN_NAME=$(echo $1 | cut -d "/" -f 2)
    if [ -d "$ZDOTDIR/plugins/$PLUGIN_NAME" ]; then
        # For plugins
        zsh_add_file "plugins/$PLUGIN_NAME/$PLUGIN_NAME.plugin.zsh" || \
        zsh_add_file "plugins/$PLUGIN_NAME/$PLUGIN_NAME.zsh"
    else
        git clone "https://github.com/$1.git" "$ZDOTDIR/plugins/$PLUGIN_NAME"
    fi
}

function zsh_add_completion() {
    PLUGIN_NAME=$(echo $1 | cut -d "/" -f 2)
    if [ -d "$ZDOTDIR/plugins/$PLUGIN_NAME" ]; then
        # For completions
		completion_file_path=$(command ls $ZDOTDIR/plugins/$PLUGIN_NAME/_*)
		fpath+="$(dirname "${completion_file_path}")"
        zsh_add_file "plugins/$PLUGIN_NAME/$PLUGIN_NAME.plugin.zsh"
    else
        git clone "https://github.com/$1.git" "$ZDOTDIR/plugins/$PLUGIN_NAME"
		fpath+=$(ls $ZDOTDIR/plugins/$PLUGIN_NAME/_*)
        [ -f $ZDOTDIR/.zccompdump ] && $ZDOTDIR/.zccompdump
    fi
	completion_file="$(basename "${completion_file_path}")"
	if [ "$2" = true ] && compinit "${completion_file:1}"
}

# 'work on', via https://coderwall.com/p/feoi0a
function wo() {
  cd $(find $CODE_DIR -maxdepth 3 -type d | grep -Ei "$*"$ | grep -Ev Pods --max-count=1)
}

function sitealive() {
  while [ true ]; do
      STATUS=$(curl -I -k -s $1 | head -n 1 | cut -d$' ' -f2);
      TIME=$(date +"%T")

      if [[ "$STATUS" == "200" ]]
      then
          echo -n "\e[32m."
      else
          echo -e "\n\e[31m $STATUS - $TIME"
      fi

      sleep 1;
  done
}

function gcuptd() {
  git add TODO.xit && git commit -m "Update TODO"
}

function dev-env(){
  project_dir=`pwd`
  project_name=`basename "$project_dir"`

  tmux has-session -t "$project_name"

  if [ $? != 0 ] ; then
    # Create the new tmux session
    tmux new-session -s "$project_name" -n editor -d

    # Open vim
    tmux send-keys -t "$project_name" 'nvim' C-m

    # Split the window
    tmux split-window -v -p 15 -t "$project_name"
    tmux select-layout -t "$project_name" main-horizontal

    # Resize the project terminal
    tmux select-pane -t 1
    tmux resize-pane -D 15

    # Create a full screen console
    tmux new-window -n console -t "$project_name"

    # Create a full screen log tail
    tmux new-window -n devlog -t "$project_name"
    tmux send-keys -t "$project_name:3" "tail -f log/development.log" C-m

    # Select the first window (with vim and small terminal)
    tmux select-window -t "$project_name:1"
  fi

  tmux attach -t "$project_name"
 }

 # Git worktree function - creates a new worktree in an adjacent directory or removes existing ones
wt() {
    # Check if at least one argument was provided
    if [ -z "$1" ]; then
        echo "Usage: wt <feature-name> | wt remove <feature-name>"
        echo "Examples:"
        echo "  wt new-login-page          # Create new worktree"
        echo "  wt remove new-login-page   # Remove existing worktree"
        return 1
    fi

    # Check if first argument is the remove subcommand
    if [ "$1" = "remove" ]; then
        # Handle remove subcommand
        _wt_remove "$2"
        return $?
    fi

    # Store the feature name from the first argument
    local feature_name="$1"

    # Get the current directory name (project folder name)
    local current_dir=$(basename "$(pwd)")

    # Get the parent directory path
    local parent_dir=$(dirname "$(pwd)")

    # Create the worktrees directory name by appending '-worktrees' to current project name
    local worktrees_dir="${current_dir}-worktrees"

    # Create the full path to the worktrees directory
    local worktrees_path="${parent_dir}/${worktrees_dir}"

    # Check if we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "‚ùå Error: Not in a git repository"
        return 1
    fi

    # Create the worktrees directory if it doesn't exist
    if [ ! -d "$worktrees_path" ]; then
        echo "üìÅ Creating worktrees directory: $worktrees_path"
        mkdir -p "$worktrees_path"
    fi

    # Create the full path for the new worktree
    local worktree_path="${worktrees_path}/${feature_name}"

    # Check if worktree directory already exists
    if [ -d "$worktree_path" ]; then
        echo "‚ùå Error: Worktree directory already exists: $worktree_path"
        return 1
    fi

    # Create the git worktree with a new branch
    echo "üåø Creating git worktree and branch '$feature_name'..."
    git worktree add -b "$feature_name" "$worktree_path"

    # Check if the worktree creation was successful
    if [ $? -ne 0 ]; then
        echo "‚ùå Failed to create worktree"
        return 1
    fi

    # Copy .env file if it exists in the current directory
    if [ -f ".env" ]; then
        cp ".env" "$worktree_path/.env"
        echo "üìÑ Copied .env to worktree"
    fi

    # List of hidden folders to copy
    local hidden_folders=(.claude)

    # Loop through each hidden folder and copy if it exists
    for dir in "${hidden_folders[@]}"; do
        if [ -d "$dir" ]; then
            cp -R "$dir" "$worktree_path"
            echo "üìÑ Copied $dir into worktree $worktree_path"
        fi
    done

    # Change to the new worktree directory
    cd "$worktree_path"

    # Run pnpm install if package.json exists
    if [ -f "package.json" ]; then
        echo "üì¶ Running pnpm install in worktree..."
        pnpm install
        # Check if pnpm install was successful
        if [ $? -eq 0 ]; then
            echo "‚úÖ pnpm install completed successfully"
        else
            echo "‚ö†Ô∏è  pnpm install encountered issues"
        fi
    else
        echo "‚ÑπÔ∏è  No package.json found, skipping pnpm install"
    fi

    # Display success message
    echo ""
    echo "‚úÖ Successfully created worktree:"
    echo "   Branch: $feature_name"
    echo "   Location: $worktree_path"
    echo "   Current directory: $(pwd)"
    echo ""
    echo "üéâ You're now in the new worktree!"
}

# Helper function to remove worktrees
_wt_remove() {
    # Check if feature name was provided for removal
    if [ -z "$1" ]; then
        echo "‚ùå Usage: wt remove <feature-name>"
        echo "Example: wt remove new-login-page"
        return 1
    fi

    # Store the feature name to remove
    local feature_name="$1"

    # Get the current directory name (project folder name)
    local current_dir=$(basename "$(pwd)")

    # Get the parent directory path
    local parent_dir=$(dirname "$(pwd)")

    # Create the worktrees directory name by appending '-worktrees' to current project name
    local worktrees_dir="${current_dir}-worktrees"

    # Create the full path to the worktrees directory
    local worktrees_path="${parent_dir}/${worktrees_dir}"

    # Create the full path for the worktree to remove
    local worktree_path="${worktrees_path}/${feature_name}"

    # Check if we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "‚ùå Error: Not in a git repository"
        return 1
    fi

    # Check if worktree directory exists
    if [ ! -d "$worktree_path" ]; then
        echo "‚ùå Error: Worktree directory does not exist: $worktree_path"
        return 1
    fi

    # Remove the git worktree
    echo "üóëÔ∏è  Removing git worktree '$feature_name'..."
    git worktree remove "$worktree_path"

    # Check if worktree removal was successful
    if [ $? -ne 0 ]; then
        echo "‚ùå Failed to remove worktree"
        return 1
    fi

    # Delete the branch (force delete to handle unmerged branches)
    echo "üåø Deleting branch '$feature_name'..."
    git branch -D "$feature_name"

    # Check if branch deletion was successful
    if [ $? -eq 0 ]; then
        echo "‚úÖ Successfully removed worktree and deleted branch '$feature_name'"
    else
        echo "‚ö†Ô∏è  Worktree removed but failed to delete branch '$feature_name'"
        echo "   You may need to delete it manually: git branch -D $feature_name"
    fi

    # Check if worktrees directory is empty and remove it
    if [ -d "$worktrees_path" ] && [ -z "$(ls -A "$worktrees_path")" ]; then
        echo "üßπ Removing empty worktrees directory..."
        rmdir "$worktrees_path"
    fi
}
